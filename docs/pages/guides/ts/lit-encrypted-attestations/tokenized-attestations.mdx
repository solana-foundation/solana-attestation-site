---
title: Encrypted Tokenized Attestations
description: Learn how to combine tokenized credentials with Lit Protocol encryption for privacy-preserving SPL tokens
date: 2025-08-12
---

# Encrypted Tokenized Attestations

This guide will walk you through integrating Lit encryption into the [Tokenized Attestations](/guides/ts/tokenized-attestations) example, creating privacy-preserving credentials that are both visible in wallets and protected by programmable access control.

## Prerequisites

Before starting this guide, you should have:

- [**Node.js**](https://nodejs.org/en/download) (v22 or later)
- [**Solana CLI**](https://solana.com/docs/intro/installation) v2.2.x or greater
- [TypeScript](http://typescriptlang.org/) Experience
- A working implementation of the [Tokenized Attestations](/guides/ts/tokenized-attestations) guide
- All of the prerequisite Lit helpers functions from the [Getting Started](/guides/ts/lit-encrypted-attestations/getting-started) guide

## Updating the Existing Implementation

Let's update the existing tokenized attestations file to utilize our Lit helpers functions to encrypt the attestation data:

### Imports and Configuration

Start by adding the necessary imports. The following are all the imports required for this code example:

```ts
import type { LitNodeClient } from '@lit-protocol/lit-node-client'
import {
    getCreateCredentialInstruction,
    getCreateSchemaInstruction,
    serializeAttestationData,
    fetchSchema,
    fetchCredential,
    deriveAttestationPda,
    deriveCredentialPda,
    deriveSchemaPda,
    getTokenizeSchemaInstruction,
    deriveSchemaMintPda,
    deriveSasAuthorityAddress,
    deriveAttestationMintPda,
    getCreateTokenizedAttestationInstruction,
    getCloseTokenizedAttestationInstruction,
    SOLANA_ATTESTATION_SERVICE_PROGRAM_ADDRESS,
    deriveEventAuthorityAddress,
    deserializeAttestationData,
    fetchAttestation,
} from 'sas-lib'
import {
    airdropFactory,
    generateKeyPairSigner,
    lamports,
    Signature,
    TransactionSigner,
    KeyPairSigner,
    Instruction,
    Address,
    Blockhash,
    createSolanaClient,
    createTransaction,
    SolanaClient,
} from 'gill'
import {
    ASSOCIATED_TOKEN_PROGRAM_ADDRESS,
    fetchMint,
    findAssociatedTokenPda,
    getMintSize,
    TOKEN_2022_PROGRAM_ADDRESS,
    estimateComputeUnitLimitFactory,
} from 'gill/programs'
import { ethers } from 'ethers'

import { createSiwsMessage, decryptAttestationData, encryptAttestationData, setupLit, signSiwsMessage } from './lit-helpers'
import { AttestationEncryptionMetadata } from './types'
import { getAuthorizedSigner1Keypair, getAuthorizedSigner2Keypair, getIssuerKeypair } from './get-keypair'
```

Next, update the existing configuration:

```ts
const CONFIG = {
    CLUSTER_OR_RPC: 'devnet',
    CREDENTIAL_NAME: 'LIT-ENCRYPTED-TOKEN-ATTESTATIONS',
    SCHEMA_NAME: 'LIT-ENCRYPTED-TOKEN-METADATA',
    SCHEMA_LAYOUT: Buffer.from([12, 12]),
    SCHEMA_FIELDS: ['ciphertext', 'dataToEncryptHash'],
    SCHEMA_VERSION: 1,
    SCHEMA_DESCRIPTION: 'Schema for Lit Protocol encrypted tokenized attestation metadata',
    ATTESTATION_DATA: {
        name: 'test-user',
        age: 100,
        country: 'usa',
    },
    ATTESTATION_EXPIRY_DAYS: 365,
    TOKEN_NAME: 'Encrypted Identity Token',
    TOKEN_METADATA: 'https://example.com/encrypted-metadata.json',
    TOKEN_SYMBOL: 'EID',
}
```

The key difference here is that our `SCHEMA_FIELDS` now define the Lit encryption metadata (`ciphertext` and `dataToEncryptHash`) rather than the actual attestation data fields.

### Updating `setupWallets`

Update the `setupWallets` function to load keypairs from keyfiles:

```ts
async function setupWallets(client: SolanaClient) {
    try {
        const payer = await generateKeyPairSigner()
        const authorizedSigner1 = await getAuthorizedSigner1Keypair() // <-- Load from keyfile using our helper function
        const authorizedSigner2 = await getAuthorizedSigner2Keypair() // <-- Load from keyfile using our helper function
        const issuer = await getIssuerKeypair() // <-- Load from keyfile using our helper function
        const testUser = await generateKeyPairSigner()

        const airdrop = airdropFactory({ rpc: client.rpc, rpcSubscriptions: client.rpcSubscriptions })
        const airdropTx: Signature = await airdrop({
            commitment: 'processed',
            lamports: lamports(BigInt(1_000_000_000)),
            recipientAddress: payer.address,
        })

        console.log(`    - Airdrop completed: ${airdropTx}`)
        return { payer, authorizedSigner1, authorizedSigner2, issuer, testUser }
    } catch (error) {
        throw new Error(`Failed to setup wallets: ${error instanceof Error ? error.message : 'Unknown error'}`)
    }
}
```

### Updating the Token Verification Function

Next we'll be modifying the existing `verifyTokenAttestation` function to handle retrieving the Lit encryption metadata from the on-chain attestation data, and decrypting it by submitting a signed SIWS message to our custom decryption Lit Action.

```ts
async function verifyTokenAttestation({
    client,
    schemaPda,
    userAddress,
    authorizedSigner,
    litDecryptionParams,
}: {
    client: SolanaClient
    schemaPda: Address
    userAddress: Address
    authorizedSigner: KeyPairSigner
    litDecryptionParams: {
        litNodeClient: LitNodeClient
        litPayerEthersWallet: ethers.Wallet
    }
}): Promise<{ isVerified: boolean; decryptedAttestationData: string | null }> {
    try {
        const schema = await fetchSchema(client.rpc, schemaPda)
        if (schema.data.isPaused) {
            console.log(`    - Schema is paused`)
            return { isVerified: false, decryptedAttestationData: null }
        }

        const [attestationPda] = await deriveAttestationPda({
            credential: schema.data.credential,
            schema: schemaPda,
            nonce: userAddress,
        })
        const [attestationMint] = await deriveAttestationMintPda({
            attestation: attestationPda,
        })

        let mintAccount
        try {
            mintAccount = await fetchMint(client.rpc, attestationMint)
        } catch (error) {
            // Mint doesn't exist - user doesn't have a tokenized attestation
            return { isVerified: false, decryptedAttestationData: null }
        }

        if (!mintAccount) return { isVerified: false, decryptedAttestationData: null }
        if (mintAccount.data.extensions.__option === 'None') {
            return { isVerified: false, decryptedAttestationData: null }
        }
        const { value: foundExtensions } = mintAccount.data.extensions

        // Verify member of group
        const [schemaMint] = await deriveSchemaMintPda({
            schema: schemaPda,
        })
        const tokenGroupMember = foundExtensions.find(ext => ext.__kind === 'TokenGroupMember')
        if (!tokenGroupMember) return { isVerified: false, decryptedAttestationData: null }
        if (tokenGroupMember.group !== schemaMint) return { isVerified: false, decryptedAttestationData: null }

        // Verify token metadata
        const tokenMetadata = foundExtensions.find(ext => ext.__kind === 'TokenMetadata')
        if (!tokenMetadata) return { isVerified: false, decryptedAttestationData: null }

        // Verify attestation PDA matches
        const attestationInMetadata = tokenMetadata.additionalMetadata.get('attestation')
        if (attestationInMetadata !== attestationPda) return { isVerified: false, decryptedAttestationData: null }

        // Verify schema PDA matches
        const schemaInMetadata = tokenMetadata.additionalMetadata.get('schema')
        if (schemaInMetadata !== schemaPda) return { isVerified: false, decryptedAttestationData: null }

        // Fetch attestation data from chain to get encryption metadata
        const attestation = await fetchAttestation(client.rpc, attestationPda)
        const attestationData = deserializeAttestationData(schema.data, attestation.data.data as Uint8Array) as AttestationEncryptionMetadata
        console.log(`    - Retrieved attestation data from chain`)

        // Decrypt attestation data
        let decryptedAttestationData: string | null = null
        try {
            const siwsMessage = createSiwsMessage({
                address: authorizedSigner.address,
                domain: 'localhost',
                uri: 'http://localhost',
                version: '1',
            })
            const siwsMessageSignature = await signSiwsMessage(siwsMessage, authorizedSigner)

            decryptedAttestationData = (await decryptAttestationData({
                ...litDecryptionParams,
                ...attestationData,
                siwsMessage,
                siwsMessageSignature,
            })) as string
        } catch (error) {
            console.error('Error while decrypting the attestation data:', error)
            return { isVerified: false, decryptedAttestationData: null }
        }

        return { isVerified: true, decryptedAttestationData }
    } catch (error) {
        console.error('There was an error while verifying the tokenized attestation:', error)
        return { isVerified: false, decryptedAttestationData: null }
    }
}
```

Let's cover the differences between the existing `verifyTokenAttestation` function and the updated one:

- New function parameters:
    - `authorizedSigner`: This parameter is expected to be one of the Credential's Authorized Signer keypairs we loaded from the keyfiles.
    - `litDecryptionParams`: This object contains a Lit Node Client and the randomly generated Ethereum wallet (used as the payer for the decryption request) which allows us to make the decryption request to the Lit network.
- New function return type:
    - `decryptedAttestationData`: This is the decrypted attestation data returned from the Lit Action after the SIWS message is authenticated and verified by the Lit network.
- New return value type for `deserializeAttestationData`:
    - Previously, this function call returned the raw attestation data that was stored on-chain, but now it's returning `AttestationEncryptionMetadata` (as defined in our `types.ts` file) which is our Lit encryption metadata: `ciphertext` and `dataToEncryptHash`.

## Setting Up the `main` Function

Now that we've setup and covered all the parts of this demo, let's run it!

The following demonstration script follows the same pattern as the Tokenized Attestation guide, but with some changes that demonstrate how to use the helper functions we created above to encrypt the attestation data.

### Prerequisites

As mentioned previously, before we can run the code example script, we need to generate the Issuer and Authorized Signers keypairs, derive the Credential PDA, and paste the address into our decryption Lit Action.

To do this, we'll add a new script to our `package.json` file:

```json
"scripts": {
  "generate-credential-pda": "ts-node generate-credential-pda.ts",
}
```

Run it:

:::code-group

```bash [npm]
npm run generate-credential-pda
```

```bash [pnpm]
pnpm generate-credential-pda
```

```bash [yarn]
yarn generate-credential-pda
```

:::

Copy the generated Credential PDA and update the `AUTHORIZED_CREDENTIAL_PDA` constant in your decryption Lit Action.

### Step 1: Setup

Create the main function:

```ts
let _litNodeClient: LitNodeClient | null = null

async function main() {
    console.log('Starting Solana Attestation Service with Lit Protocol encrypted tokenized attestation demo\n')

    const client: SolanaClient = createSolanaClient({ urlOrMoniker: CONFIG.CLUSTER_OR_RPC })

    // Step 1: Setup wallets and fund payer
    console.log('1. Setting up wallets and funding payer...')
    const { payer, authorizedSigner1, authorizedSigner2, issuer, testUser } = await setupWallets(client)

    // Step 2: Setup Lit

    // Step 3: Setting up Credential

    // Step 4: Setting up Schema

    // Step 5: Tokenizing Schema

    // Step 6: Creating and Encrypting Tokenized Attestation

    // Step 7: Verifying Tokenized Attestations

    // Step 8: Closing Tokenized Attestation
}
```

The current code includes spaces for 8 steps. We've started by creating our client and calling our `setupWallets` function. Let's add the remaining steps next.

### Step 2: Setup Lit

This step is creating our Lit node client, connecting us to the Lit Datil-dev network. Additionally, the Ethereum wallet we'll be using as the payer for the decryption request is generated and returned to us. Add the following code to your `main` function after Step 1:

_Note: remember that while using the Lit Datil-dev network, payment is actually required, but providing a wallet is still required._

Create the file `setup-lit.ts` in our `lit` helpers directory and export the function `setupLit`:

```ts
// Step 2: Setup Lit
console.log('2. Setting up Lit...')
const { litNodeClient, litPayerEthersWallet } = await setupLit()
_litNodeClient = litNodeClient
```

### Step 3: Setup Credential

Next we're going to create our Credential account if it doesn't already exist, or fetch the existing one if it does.

Unlike the [Tokenized Attestation](/guides/ts/tokenized-attestations.mdx) guide that always creates a new Credential keypair and account every time you run the demo, this demo reuses the Issuer keypair so that we have a static Credential PDA to use in out Lit Action.

Add the following code to your `main` function after Step 2:

```ts
// Step 3: Create Credential (if it doesn't exist)
console.log('\n3. Setting up Credential...')
const [credentialPda] = await deriveCredentialPda({
    authority: issuer.address,
    name: CONFIG.CREDENTIAL_NAME,
})

try {
    const existingCredential = await fetchCredential(client.rpc, credentialPda)
    console.log(`    - Credential already exists: ${credentialPda}`)
    console.log(`    - Authority: ${existingCredential.data.authority}`)
    console.log(`    - Current authorized signers: ${existingCredential.data.authorizedSigners.length}`)
} catch (error) {
    console.log(`    - Creating new credential: ${credentialPda}`)
    const createCredentialInstruction = getCreateCredentialInstruction({
        payer,
        credential: credentialPda,
        authority: issuer,
        name: CONFIG.CREDENTIAL_NAME,
        signers: [authorizedSigner1.address, authorizedSigner2.address],
    })
    await sendAndConfirmInstructions(client, payer, [createCredentialInstruction], 'Credential created')
    console.log(`    - Credential created successfully`)
}
```

### Step 4: Setup Schema

Next, we need to define our _Schema_ to define the structure of data that can be attested (`ciphertext` and `dataToEncryptHash` in our example).

Just like the Credential PDA, we're going to check if the Schema PDA already exists, and create it if it doesn't.

Add the following code to your `main` function after Step 3:

```ts
// Step 4: Create Schema (if it doesn't exist)
console.log('\n4. Setting up Schema...')
const [schemaPda] = await deriveSchemaPda({
    credential: credentialPda,
    name: CONFIG.SCHEMA_NAME,
    version: CONFIG.SCHEMA_VERSION,
})

try {
    const existingSchema = await fetchSchema(client.rpc, schemaPda)
    console.log(`    - Schema already exists: ${schemaPda}`)
    console.log(`    - Schema name: ${new TextDecoder().decode(existingSchema.data.name)}`)
    console.log(`    - Version: ${existingSchema.data.version}`)
} catch (error) {
    console.log(`    - Creating new schema: ${schemaPda}`)
    const createSchemaInstruction = getCreateSchemaInstruction({
        authority: issuer,
        payer,
        name: CONFIG.SCHEMA_NAME,
        credential: credentialPda,
        description: CONFIG.SCHEMA_DESCRIPTION,
        fieldNames: CONFIG.SCHEMA_FIELDS,
        schema: schemaPda,
        layout: CONFIG.SCHEMA_LAYOUT,
    })
    await sendAndConfirmInstructions(client, payer, [createSchemaInstruction], 'Schema created')
    console.log(`    - Schema created successfully`)
}
```

### Step 5: Tokenize Schema

Before utilizing tokenized attestations, you must first tokenize the schema. This step transforms a regular attestation schema into a tokenized schema that serves as a "group" for individual attestation tokens.

The code first checks if the schema is already tokenized by trying to fetch an existing schema mint. If it doesn't exist, it creates:

1. A Program Derived Address for the Token-2022 mint representing this schema
2. The SAS Authority that will manage all tokenized credentials
3. Enables the schema mint to act as a group that attestation tokens can join
4. The actual Token-2022 mint with the calculated space requirements

This infrastructure allows all attestation tokens created from this schema to be members of the same group, enabling wallet integrations to display them as related credentials while maintaining the schema's data structure definitions.

```ts
// Step 5: Tokenize Schema (if not already tokenized)
console.log('\n5. Tokenizing Schema...')
const [schemaMint] = await deriveSchemaMintPda({
    schema: schemaPda,
})

try {
    const existingMint = await fetchMint(client.rpc, schemaMint)
    console.log(`    - Schema already tokenized: ${schemaMint}`)
} catch (error) {
    console.log(`    - Tokenizing schema...`)
    const sasPda = await deriveSasAuthorityAddress()
    const schemaMintAccountSpace = getMintSize([
        {
            __kind: 'GroupPointer',
            authority: sasPda,
            groupAddress: schemaMint,
        },
    ])

    const createTokenizeSchemaInstruction = getTokenizeSchemaInstruction({
        payer,
        authority: issuer,
        credential: credentialPda,
        schema: schemaPda,
        mint: schemaMint,
        sasPda,
        maxSize: schemaMintAccountSpace,
        tokenProgram: TOKEN_2022_PROGRAM_ADDRESS,
    })

    await sendAndConfirmInstructions(client, payer, [createTokenizeSchemaInstruction], 'Schema tokenized')
    console.log(`    - Schema Mint: ${schemaMint}`)
}
```

### Step 6: Create Encrypted Tokenized Attestation

This step creates the actual tokenized attestation by combining Lit Protocol encryption with Token-2022 minting. The process involves:

1. Deriving PDAs with getting the attestation PDA and its corresponding mint PDA
2. Encrypting the attestation with Lit Protocol before storing it on-chain
3. Calculating token extensions by determining the space needed for multiple Token-2022 extensions (NonTransferable, TokenMetadata, GroupMember, etc.)
4. Minting the token by creating both the on-chain attestation account with encrypted data and minting a soulbound NFT to the user's wallet

The result is a privacy-preserving credential that appears as a token in wallets but stores only encrypted metadata on-chain, with the actual data only able to be decrypted by the authorized credential signers.

```ts
// Step 6: Create and Encrypt Tokenized Attestation
console.log('\n6. Creating Tokenized Attestation...')
const [attestationPda] = await deriveAttestationPda({
    credential: credentialPda,
    schema: schemaPda,
    nonce: testUser.address,
})
const [attestationMint] = await deriveAttestationMintPda({
    attestation: attestationPda,
})

const schema = await fetchSchema(client.rpc, schemaPda)
const expiryTimestamp = Math.floor(Date.now() / 1000) + CONFIG.ATTESTATION_EXPIRY_DAYS * 24 * 60 * 60
const sasPda = await deriveSasAuthorityAddress()
const [recipientTokenAccount] = await findAssociatedTokenPda({
    mint: attestationMint,
    owner: testUser.address,
    tokenProgram: TOKEN_2022_PROGRAM_ADDRESS,
})

// Encrypt the attestation data
const attestationEncryptionMetadata = await encryptAttestationData({
    attestationData: new TextEncoder().encode(JSON.stringify(CONFIG.ATTESTATION_DATA)),
    litNodeClient,
})

const attestationMintAccountSpace = getMintSize([
    {
        __kind: 'GroupMemberPointer',
        authority: sasPda,
        memberAddress: attestationMint,
    },
    { __kind: 'NonTransferable' },
    {
        __kind: 'MetadataPointer',
        authority: sasPda,
        metadataAddress: attestationMint,
    },
    { __kind: 'PermanentDelegate', delegate: sasPda },
    { __kind: 'MintCloseAuthority', closeAuthority: sasPda },
    {
        __kind: 'TokenMetadata',
        updateAuthority: sasPda,
        mint: attestationMint,
        name: CONFIG.TOKEN_NAME,
        symbol: CONFIG.TOKEN_SYMBOL,
        uri: CONFIG.TOKEN_METADATA,
        additionalMetadata: new Map([
            ['attestation', attestationPda],
            ['schema', schemaPda],
        ]),
    },
    {
        __kind: 'TokenGroupMember',
        group: schemaMint,
        mint: attestationMint,
        memberNumber: 1,
    },
])

const createTokenizedAttestationInstruction = await getCreateTokenizedAttestationInstruction({
    payer,
    authority: authorizedSigner1,
    credential: credentialPda,
    schema: schemaPda,
    attestation: attestationPda,
    schemaMint: schemaMint,
    attestationMint,
    sasPda,
    recipient: testUser.address,
    nonce: testUser.address,
    expiry: expiryTimestamp,
    data: serializeAttestationData(schema.data, {
        ...attestationEncryptionMetadata,
    }),
    name: CONFIG.TOKEN_NAME,
    uri: CONFIG.TOKEN_METADATA,
    symbol: CONFIG.TOKEN_SYMBOL,
    mintAccountSpace: attestationMintAccountSpace,
    recipientTokenAccount: recipientTokenAccount,
    associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ADDRESS,
    tokenProgram: TOKEN_2022_PROGRAM_ADDRESS,
})

await sendAndConfirmInstructions(client, payer, [createTokenizedAttestationInstruction], 'Tokenized attestation created')
console.log(`    - Attestation PDA: ${attestationPda}`)
console.log(`    - Attestation Mint: ${attestationMint}`)
```

### Step 7: Verify Attestations

This step demonstrates the comprehensive verification process for encrypted tokenized attestations. The verification involves:

1. Checks that the token exists and has proper Token-2022 extensions
2. Verifies the token is a member of the correct schema group
3. Validates that token metadata references the correct attestation and schema PDAs
4. Uses Lit Protocol to decrypt the attestation data, which only succeeds if the signer is authorized
5. Tests with unauthorized signers to confirm the access control system works correctly

The verification process combines on-chain token verification with Lit's decentralized access control, ensuring both the integrity of the tokenized credential and the privacy of its data.

```ts
// Step 7: Verify Tokenized Attestations
console.log('\n7. Verifying Tokenized Attestations...')

const verification = await verifyTokenAttestation({
    client,
    schemaPda,
    userAddress: testUser.address,
    authorizedSigner: authorizedSigner1,
    litDecryptionParams: {
        litNodeClient,
        litPayerEthersWallet,
    },
})

console.log(`    - Test User is ${verification.isVerified ? 'verified' : 'not verified'}`)
console.log(`    - Test User's token is ${verification.isVerified ? 'valid' : 'invalid'}`)
if (verification.decryptedAttestationData) {
    console.log(`    - Decrypted Attestation Data: ${verification.decryptedAttestationData}`)
}

const randomUser = await generateKeyPairSigner()
const randomVerification = await verifyTokenAttestation({
    client,
    schemaPda,
    userAddress: randomUser.address,
    authorizedSigner: authorizedSigner2,
    litDecryptionParams: {
        litNodeClient,
        litPayerEthersWallet,
    },
})
console.log(`    - Random User is ${randomVerification.isVerified ? 'verified' : 'not verified'}`)

// Test with unauthorized signer (should fail)
console.log('\n    Testing with unauthorized signer (should fail)...')
const unauthorizedSigner = await generateKeyPairSigner()
console.log(`    - Unauthorized signer address: ${unauthorizedSigner.address}`)

const unauthorizedResult = await verifyTokenAttestation({
    client,
    schemaPda,
    userAddress: testUser.address,
    authorizedSigner: unauthorizedSigner,
    litDecryptionParams: {
        litNodeClient,
        litPayerEthersWallet,
    },
})

if (unauthorizedResult.isVerified) {
    console.log(`    - âŒ Unauthorized signer is verified`)
} else {
    console.log(`    - âœ… Unauthorized signer is not verified`)
}
```

### Step 8: Close Tokenized Attestation

This final step demonstrates credential revocation by permanently removing both the on-chain attestation data and the tokenized representation. The process involves:

1. Gets the event authority address required for emitting close events in the SAS program.
2. Uses `getCloseTokenizedAttestationInstruction` to create the close instruction with proper Token-2022 program integration.
3. Completely removes the token from the recipient's wallet by burning and closing the mint operations.
4. Closes the attestation account, recovering the rent and removing the encrypted data from the blockchain.

This step showcases how credentials can be revoked in a way that's both visible (token disappears from wallet) and permanent (encrypted data is removed from chain), providing a complete lifecycle management solution for tokenized credentials.

```ts
// Step 8: Close Tokenized Attestation
console.log('\n8. Closing Tokenized Attestation...')
const eventAuthority = await deriveEventAuthorityAddress()

const closeTokenizedAttestationInstruction = getCloseTokenizedAttestationInstruction({
    payer,
    authority: authorizedSigner1,
    credential: credentialPda,
    attestation: attestationPda,
    eventAuthority,
    attestationProgram: SOLANA_ATTESTATION_SERVICE_PROGRAM_ADDRESS,
    attestationMint,
    sasPda,
    attestationTokenAccount: recipientTokenAccount,
    tokenProgram: TOKEN_2022_PROGRAM_ADDRESS,
})

await sendAndConfirmInstructions(client, payer, [closeTokenizedAttestationInstruction], 'Tokenized Attestation closed')

// Return summary data for pretty printing
return {
    addresses: {
        credentialPda,
        schemaPda,
        attestationPda,
        schemaMint,
        attestationMint,
        testUserAddress: testUser.address,
    },
    verification,
    randomVerification,
    unauthorizedResult,
    config: CONFIG,
    attestationEncryptionMetadata,
}
```

### Calling the Main Function

The following code calls the `main` function we've just finished defining, validates the results, and also handles the pretty printing of the results.

Add the following code after your `main` function to execute it:

```ts
main()
    .then(results => {
        console.log('\n' + '='.repeat(80))
        console.log('SOLANA ATTESTATION SERVICE WITH LIT PROTOCOL ENCRYPTED ATTESTATION DEMO')
        console.log('='.repeat(80))

        console.log('\nðŸ“‹ DEMO CONFIGURATION:')
        console.log(`   Network: ${results.config.CLUSTER_OR_RPC}`)
        console.log(`   Organization: ${results.config.CREDENTIAL_NAME}`)
        console.log(`   Schema: ${results.config.SCHEMA_NAME} (v${results.config.SCHEMA_VERSION})`)
        console.log(`   Token: ${results.config.TOKEN_NAME} (${results.config.TOKEN_SYMBOL})`)

        console.log('\nðŸ”‘ CREATED ACCOUNTS:')
        console.log(`   Credential PDA:    ${results.addresses.credentialPda}`)
        console.log(`   Schema PDA:        ${results.addresses.schemaPda}`)
        console.log(`   Schema Mint:       ${results.addresses.schemaMint}`)
        console.log(`   Attestation PDA:   ${results.addresses.attestationPda}`)
        console.log(`   Attestation Mint:  ${results.addresses.attestationMint}`)
        console.log(`   Test User:         ${results.addresses.testUserAddress}`)

        console.log('\nðŸ§ª VERIFICATION TEST RESULTS:')

        // Test User Verification
        const testUserStatus = results.verification.isVerified ? 'âœ… PASSED' : 'âŒ FAILED'
        console.log(`   Test User Verification:     ${testUserStatus}`)
        if (results.verification.isVerified) {
            console.log(`   Encrypted Metadata:`)
            console.log(`     - Ciphertext: ${results.attestationEncryptionMetadata.ciphertext.substring(0, 50)}...`)
            console.log(`     - Data Hash: ${results.attestationEncryptionMetadata.dataToEncryptHash}`)
            if (results.verification.decryptedAttestationData) {
                console.log(`   Decrypted Attestation Data: ${results.verification.decryptedAttestationData}`)
            }
        }

        // Random User Verification (should fail)
        const randomUserStatus = !results.randomVerification.isVerified ? 'âœ… PASSED' : 'âŒ FAILED'
        console.log(`   Random User Verification:   ${randomUserStatus} (correctly rejected)`)

        // Unauthorized Signer Test (should fail)
        const unauthorizedStatus = !results.unauthorizedResult.isVerified ? 'âœ… PASSED' : 'âŒ FAILED'
        console.log(`   Unauthorized Signer Test:   ${unauthorizedStatus} (correctly rejected)`)

        const allTestsPassed = results.verification.isVerified && !results.randomVerification.isVerified && !results.unauthorizedResult.isVerified

        if (allTestsPassed) {
            console.log('   âœ… ALL TESTS PASSED! Demo completed successfully.')
        } else {
            console.log('   âŒ  Some tests failed. Please review the results above.')
        }

        console.log('\n' + '='.repeat(80))
    })
    .catch(error => {
        console.error('\nâŒ Demo failed:', error)
        process.exit(1)
    })
    .finally(() => {
        _litNodeClient?.disconnect()
    })
```

## Running the Demonstration

To test your encrypted tokenized attestation workflow:

:::note
In order to run the demonstration using the following command, make sure you're `package.json` contains the following:

```json
"scripts": {
  "start": "ts-node tokenized-attestation-demo.ts",
  "build": "tsc"
}
```

If you've copied the existing `tokenized-attestation-demo.ts` file and renamed it for this encryption code example, make sure you use the new file name here in the `start` script.

:::

:::code-group

```bash [npm]
npm start
```

```bash [pnpm]
pnpm start
```

```bash [yarn]
yarn start
```

:::

Expected output:

```bash
lit-js-sdk:constants:errors deprecated LitErrorKind is deprecated and will be removed in a future version. Use LIT_ERROR_KIND instead. node:internal/modules/cjs/loader:1692:14
Starting Solana Attestation Service with Lit Protocol encrypted tokenized attestation demo

1. Setting up wallets and funding payer...
Got Authorized Signer 1 keypair with address: 8XMEduQLuEw4LHGD6a66LeH1TKJsa3rpghGnM1mjbHCN
Got Authorized Signer 2 keypair with address: 8BDVzsSvqFFMDpcqcueTBVnPu33aqP72XJq3QUfGAeho
Got Issuer keypair with address: EFjEXBpSHL7xXUNZEQf5CKWD7dZHkLfqc1i9tceoqms2
    - Airdrop completed: 2PknYz2Pzf9VMFGRW4ZLv5E76yWia6YDMksvjKhZTN7M9xcvzZ85UYBZ6RjeyTk6gR2pnd2ijaWR592wJ2btT8Hd
2. Setting up Lit...
lit-js-sdk:constants:constants deprecated LogLevel is deprecated and will be removed in a future version. Use LOG_LEVEL instead. node_modules/.pnpm/@lit-protocol+core@7.2.1_typescript@5.8.3/node_modules/@lit-protocol/core/src/lib/lit-core.js:453:119

3. Setting up Credential...
    - Credential already exists: 4Uk8L52m58FEhU9ECqwzh7KtL1698PM82xPpLnwhPmr7
    - Authority: EFjEXBpSHL7xXUNZEQf5CKWD7dZHkLfqc1i9tceoqms2
    - Current authorized signers: 2

4. Setting up Schema...
    - Schema already exists: E7Riv3KhCcU33pvonkXU1A7CojDpvJGzrv7HwaNNyBwi
    - Schema name: LIT-ENCRYPTED-TOKEN-METADATA
    - Version: 1

5. Tokenizing Schema...
    - Schema already tokenized: J9vbrzrXVhfKYN69ADYFbNjZYNem5oQTqrnBTq76VYLn

6. Creating Tokenized Attestation...
using deprecated parameters for `initSync()`; pass a single object instead
    - Tokenized attestation created: 3AEAjSemmBoZteZm5czdokbzc1yHtJYBQGqGrimsZbq92TYRiRAheuqaSaWoAukRkqNAtFZXhiRgFXjeyjkspUL
    - Attestation PDA: Ad4yLyhW9T9Q3VaCkgcnsARDwbprWxBK7YDJyyshjEoF
    - Attestation Mint: 34JxLEer3synJnsmKmcZTbycDCk7AdXQAJQ3WqG2LKVa

7. Verifying Tokenized Attestations...
    - Retrieved attestation data from chain
Storage key "lit-session-key" is missing. Not a problem. Continue...
Storage key "lit-wallet-sig" is missing. Not a problem. Continue...
Unable to store walletSig in local storage. Not a problem. Continue...
    - Test User is verified
    - Test User's token is valid
    - Decrypted Attestation Data: {"name":"test-user","age":100,"country":"usa"}
    - Random User is not verified

    Testing with unauthorized signer (should fail)...
    - Unauthorized signer address: 2Cf17RYkNad2FP8WPmsiQbvQnvrprsppkaFmHK7PEzYU
    - Retrieved attestation data from chain
Storage key "lit-session-key" is missing. Not a problem. Continue...
Storage key "lit-wallet-sig" is missing. Not a problem. Continue...
Unable to store walletSig in local storage. Not a problem. Continue...
Error while decrypting the attestation data: Error: An unexpected error occurred while decrypting the attestation data: Failed to decrypt attestation data: {"success":false,"message":"Signer is not authorized to decrypt","authorizedSigners":["8XMEduQLuEw4LHGD6a66LeH1TKJsa3rpghGnM1mjbHCN","8BDVzsSvqFFMDpcqcueTBVnPu33aqP72XJq3QUfGAeho"],"requestingSigner":"2Cf17RYkNad2FP8WPmsiQbvQnvrprsppkaFmHK7PEzYU"}
    at decryptAttestationData (lit/decrypt-attestation-data.ts:80:15)
    at processTicksAndRejections (node:internal/process/task_queues:105:5)
    at async verifyTokenAttestation (decrypt-attestation-data.ts:201:40)
    at async main (decrypt-attestation-data.ts:456:32)
    - âœ… Unauthorized signer is not verified

8. Closing Tokenized Attestation...
    - Tokenized Attestation closed: 3TVGek5VUEmsjygruVYRyJRBuAsf7uYmFnxw5BhyjkDApL7DVzrMEcG232sS6X7hRosy74vnKj4KNFZYXTQCuy36

================================================================================
SOLANA ATTESTATION SERVICE WITH LIT PROTOCOL ENCRYPTED ATTESTATION DEMO
================================================================================

ðŸ“‹ DEMO CONFIGURATION:
   Network: devnet
   Organization: LIT-ENCRYPTED-TOKEN-ATTESTATIONS
   Schema: LIT-ENCRYPTED-TOKEN-METADATA (v1)
   Token: Encrypted Identity Token (EID)

ðŸ”‘ CREATED ACCOUNTS:
   Credential PDA:    4Uk8L52m58FEhU9ECqwzh7KtL1698PM82xPpLnwhPmr7
   Schema PDA:        E7Riv3KhCcU33pvonkXU1A7CojDpvJGzrv7HwaNNyBwi
   Schema Mint:       J9vbrzrXVhfKYN69ADYFbNjZYNem5oQTqrnBTq76VYLn
   Attestation PDA:   Ad4yLyhW9T9Q3VaCkgcnsARDwbprWxBK7YDJyyshjEoF
   Attestation Mint:  34JxLEer3synJnsmKmcZTbycDCk7AdXQAJQ3WqG2LKVa
   Test User:         BfLgYU4Zf9N1infWDoxMP83pxSKywmAaSiA8ghKNDPDU

ðŸ§ª VERIFICATION TEST RESULTS:
   Test User Verification:     âœ… PASSED
   Encrypted Metadata:
     - Ciphertext: oc+2f+GJOXIr5R6XAC+aDgIJFvK+GbuOn9wa8qsBEzbvMChcJS...
     - Data Hash: 4efa888818ad5ba81b0e459037eb8c62a3f0bdf401de5372e21d8aa132a0a808
   Decrypted Attestation Data: {"name":"test-user","age":100,"country":"usa"}
   Random User Verification:   âœ… PASSED (correctly rejected)
   Unauthorized Signer Test:   âœ… PASSED (correctly rejected)
   âœ… ALL TESTS PASSED! Demo completed successfully.

================================================================================
```

The `lit-js-sdk` logs are expected, and can be ignored, and the `There was an error while decrypting the attestation data` error is for our decryption attempt using an unauthorized signer in [Step 7](#step-7-verify-attestation).

If you see `âœ… ALL TESTS PASSED! Demo completed successfully.`, you've successfully completed the demo!

## Wrap Up

Congratulations! You've successfully implemented a complete Tokenized Solana Attestation Service system using Lit Protocol to encrypt the attestation data. You now have a working demonstration that shows how to:

- **Create credentials** that represent issuing authorities
- **Define schemas** for encrypted attestation metadata (`ciphertext` and `dataToEncryptHash`)
- **Tokenize schemas** to create credential groups for wallet visibility
- **Encrypt attestation data using Lit Protocol** with custom access control conditions
- **Issue encrypted tokenized attestations** as SPL tokens, storing only Lit encryption metadata on-chain
- **Manage authorized signers** for enhanced security and dynamic access control
- **Verify and decrypt attestations** programmatically, ensuring only authorized signers can access the underlying data
- **Close (revoke) tokenized attestations** by burning tokens and removing encrypted data

The Solana Attestation Service (SAS) provides a powerful foundation for building trust and identity systems on Solana. Whether you're creating compliance systems, financial credentials, professional certifications, or gaming achievements, SAS gives you the tools to issue and verify claims in a decentralized, transparent way.

## Additional Resources

- Need help? Ask questions the [Solana Stack Exchange](https://solana.stackexchange.com/) with a `SAS` tag.
- [**SAS Source Code**](https://github.com/solana-foundation/solana-attestation-service)
- [**Complete Code Example**](https://github.com/solana-foundation/solana-attestation-service/tree/master/examples/typescript/attestation-flow-guides/src/lit/sas-tokenized-lit-demo.ts)
- [**Solana Developer Resources**](https://solana.com/developers)
- [**Lit Protocol Documentation**](https://developer.litprotocol.com/)
- [**Lit Protocol Builders Telegram Group**](https://t.me/+aa73FAF9Vp82ZjJh)
